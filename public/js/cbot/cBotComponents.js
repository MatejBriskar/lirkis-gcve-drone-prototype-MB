"use strict";

AFRAME.registerComponent("cbot-cleaning", {
    schema: {
        command: {type: "number", default: 1},
        maxMsrblDst: {type: "number", default: 15},
        safeDstCl: {type: "number", default: 3},
        safeDstMov: {type: "number", default: 3},
        cleanRange: {type: "number", default: 0.1}
    },

    init: function () {
        this.obj = this.el.object3D;
        this.head = document.querySelector(".head");
        this.movementSpeed = 0.5;
      
        this.sampleTime = 1000 / 60; // default sample time is 16,667 seconds = 60fps
        this.clock = new THREE.Clock(true);
        // this.lastTime = this.getTime() - this.sampleTime;

        this.botOn = false;
        this.botCleaning = false;
        this.botEvading = false;
        this.angleInMin = 0;
        this.dst = 0;

        // maxMsrblDst, safeDstCl, safeDstMov, cleanRange
        this.controller = new cbot.CBotController(
            this.data.maxMsrblDst,
            this.data.safeDstCl,
            this.data.safeDstMov,
            this.data.cleanRange
        );

        this.dirtyPositions = [];
        document.querySelectorAll("[cbot-dirty-position]").forEach(pos => {
            this.dirtyPositions.push(pos);
        });
    },
  
    getTime: function () {
        return new Date().getTime();
    },

    tick: function () {
        if (!cbotLoggedIn) return;
      
        let deltaTime = this.clock.getDelta();
      
        let currentCleaningPos;
        let currentBotPos = this.obj.getWorldPosition(new THREE.Vector3());
        let targetVector = new THREE.Vector3();

        if (this.dirtyPositions.length !== 0) {
            currentCleaningPos = this.dirtyPositions[0].object3D.position;
            targetVector = targetVector.subVectors(currentCleaningPos, currentBotPos);
        }

        // calculate angle to next position
        let angleInDeg = 0, angleInRad = 0, dst = 0;

        if (!this.isVector3Zero(targetVector)) {
            angleInRad = Math.atan2(targetVector.x, -targetVector.z);
            angleInDeg = this.normalizeAngleDeg(THREE.Math.radToDeg(angleInRad));
            // calculate distance to next position
            dst = currentBotPos.distanceTo(currentCleaningPos);

            if (dst < 0.05) dst = 0;
        }

        let distances = this.getUsersDistances(currentBotPos);

        // command, p2gAngleInMin, p2gDst, nne, ene, ese, sse, ssw, wsw, wnw, nnw
        let commands = this.controller.updateAndEvaluate(
            this.data.command,
            Math.floor(angleInDeg * 60),
            dst,
            distances[0],
            distances[1],
            distances[2],
            distances[3],
            distances[4],
            distances[5],
            distances[6],
            distances[7]
        );

        this.botOn = commands[0];
        this.botCleaning = commands[1];
        this.botEvading = commands[2];
        this.angleInMin = commands[3];
        this.dst = commands[4];

        if (this.botOn) {
            if (this.dst < 0.05) {
                if (this.botCleaning) {
                    this.cleanPosition(this.dirtyPositions[0], deltaTime);
                }

                // stop cleaning, if all positions are clean
                if (this.dirtyPositions.length === 0) {
                    console.log("done cleaning");
                    this.el.setAttribute("cbot-cleaning", "command", 3);
                }
            } else {
                // set rotation according to controller
                let a = this.angleInMin / 60;

                // flip angles from controller representation to a-frame representation
                a = this.mapValueToRange(a, 0, 360, 360, 0);
                this.obj.rotation.y = THREE.Math.degToRad(a);

                // move forward
                this.obj.translateZ(-this.movementSpeed * deltaTime);
            }
        }

        this.updateColor();
    },

    cleanPosition: function (entity, deltaTime) {
        if (entity == null) return;

        let data = entity.getAttribute("cbot-dirty-position");

        if (data.isClean) {
            entity.parentNode.removeChild(entity);
            this.dirtyPositions.shift();
            return;
        }

        let dirtiness = data.dirtiness - (1 * (deltaTime / (this.sampleTime / 1000)));
      
        // console.log(1 * (deltaTime / (this.sampleTime / 1000)));
      
        entity.setAttribute("cbot-dirty-position", "dirtiness", dirtiness);
    },

    getUsersDistances: function (botPos) {
        let distances = [];
        let i;

        for (i = 0; i < 8; i++) {
            distances[i] = this.data.maxMsrblDst;
        }

        let clientPos = new THREE.Vector3();
        let directionVector = new THREE.Vector3();
        let angleInRad, angleInDeg, dst, cp, index;

        for (i = 0; i < clientsPosition.length; i++) {
            cp = clientsPosition[i];
            clientPos.set(cp.positionX, cp.positionY, cp.positionZ);

            // calculate angle between bot and client
            directionVector.subVectors(clientPos, botPos);
            angleInRad = Math.atan2(directionVector.x, -directionVector.z);
            angleInDeg = this.normalizeAngleDeg(THREE.Math.radToDeg(angleInRad));

            // calculate distance
            dst = botPos.distanceTo(clientPos);

            index = Math.floor(angleInDeg / 45);

            // only set smallest distance
            if (dst < distances[index]) {
                distances[index] = dst;
            }
        }

        return distances;
    },

    updateColor: function () {
        let color;

        if (this.botCleaning) {
            color = this.botEvading ? "red" : "orange";
        } else if (this.botOn) {
            color = this.botEvading ? "red" : "green";
        } else {
            color = "white";
        }

        this.head.setAttribute("material", "color", color);
    },

    normalizeAngleDeg: function (angle) {
        angle = angle % 360;
        return angle >= 0 ? angle : angle + 360;
    },

    normalizeAngleRad: function (angle) {
        angle = angle % (2 * Math.PI);
        return angle >= 0 ? angle : angle + 2 * Math.PI;
    },

    isVector3Zero: function (vector) {
        return vector.x === 0 && vector.y === 0 && vector.z === 0;
    },

    mapValueToRange: function (value, fromMin, fromMax, toMin, toMax) {
        return (value - fromMin) * (toMax - toMin) / (fromMax - fromMin) + toMin;
    }
});

AFRAME.registerComponent("cbot-dirty-position", {
    schema: {
        dirtiness: {type: "int", default: 250},
        isClean: {type: "boolean", default: false}
    },

    init: function () {
        this.el.setAttribute("material", "color", "brown");
        this.el.setAttribute("material", "transparent", true);
    },

    update: function () {
        this.el.setAttribute("material", "opacity", this.data.dirtiness / 250);

        if (this.data.dirtiness <= 0) {
            this.el.setAttribute("cbot-dirty-position", "isClean", true);
        }
    }
});
