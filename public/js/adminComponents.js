/*** Script for getting information from NAF about connected clients
 * @templateNameSearchPosition - name of template to get clients positions
 * @templateNameSearchRotation - name of template to get clients head rotation
 * @projectUrl - basic project URL
 * @saveUserActivityEndpoint - endpoint on server to save disconnected user
 * @getUserHistoryEndpoint - endpoint on server to get user history
 * @adminIsConnected - flag, if admin is connected to scene
 * @classNameToGetUsername - classname for getting username from shared entity
 * @kickDataChannel - datachannel for kicking another clients from list, must match with guest client kick datachannel
 * @adminIdBroadcastChannel - datachannel for sharing part of admin ID, integrity that only Admin can kick me must match with guest client kick datachannel
 * @cBotHistoryUsername - username of cBot, not included to users history
 * @cBotTemplateName - template to get cbot position
 * @cBotTemplateRotation - template to get cBot rotation
 * @adminHistoryUsername - username of admin, not included to users history
 * @usageOfClientPositionComponent - toggle if admin has client position component
 * @usageOfConnectedClientsListComponent - toggle if admin has connected clients component
 * @enableUserHistory - if function to get userHistory is enabled - if component for user history in used in admin.html
 ***/
const templateNameSearchPosition = "#avatar-body";
const templateNameSearchRotation = "#avatar-template";
const projectUrl = window.location.href.substring(0, window.location.href.lastIndexOf("/"));
const saveUserActivityEndpoint = "/writeUser";
const getUserHistoryEndpoint = "/getUserHistory";
let adminIsConnected = false;
const classNameToGetUsername = "idtext";
const kickDataChannel = "disconnect";
const adminIdBroadcastChannel = "adminSecret";
const cBotHistoryUsername = "cBot";
const cBotTemplateName = "#avatar-cBotbody";
const cBotTemplateRotation = "#avatar-cBottemplate";
const adminHistoryUsername = "ADMIN";
let usageOfClientPositionComponent = false;
let usageOfConnectedClientsListComponent = false;
let enableUserHistory = false;

/***
 * @connectedClients - list of connected clients
 * @clientsHistory - list with history of users activity obtain from server
 ***/
let connectedClients = [];
const getClientsEntitiesDOM = () => document.getElementsByClassName('bodyavatar')
const getUserNameByOwnerId = (ownerId) => {
    const elementWithUsername = document.getElementsByClassName(classNameToGetUsername);
    if (elementWithUsername) {
        for (let item of elementWithUsername) {
            if (
                item.parentEl.components.networked.attrValue.owner === ownerId
            ) {
                return clientUsername = item.components.text.attrValue.value;
                break;
            }
        }
    }
}
const getClientsObjectsDOM = () => {
    const clientsPositions = [];
    getClientsEntitiesDOM().forEach((client) => {
        const clientNetworked = client.getAttribute('networked');
        //toto tu necham keby trebalo specialne pre cbota abo co
        // if (
        //     client.getAttribute("networked").networkId ===
        //     templateNameSearchRotation
        // ) {
        //
        // }
        const entityIdRotation = client.querySelector('.avatar').getAttribute('networked').networkId;
        let clientToArray = {
            userName: getUserNameByOwnerId(clientNetworked.owner),
            entityId: clientNetworked.networkId,
            userId: clientNetworked.owner,
            entityIdRotation
        };
        if (clientNetworked.networkId) {
            let clientEntityPosition = NAF.entities.getEntity(clientNetworked.networkId)
                .object3D.position;
            const positionX = clientEntityPosition.x.toFixed(4);
            const positionY = clientEntityPosition.y.toFixed(4);
            const positionZ = clientEntityPosition.z.toFixed(4);
            clientToArray = {...clientToArray, positionX, positionY, positionZ};
        }
        if (entityIdRotation) {
            let clientEntityRotation = NAF.entities.getEntity(
                entityIdRotation
            ).object3D.rotation;
            const rotationX = clientEntityRotation.x.toFixed(4);
            const rotationY = clientEntityRotation.y.toFixed(4);
            const rotationZ = clientEntityRotation.z.toFixed(4);
            clientToArray = {...clientToArray, rotationX, rotationY, rotationZ};
        }
        clientToArray && clientsPositions.push(clientToArray);
    })
    return clientsPositions;
}
let clientsHistory = [];

/***Usage of admin components with tables ***/
const showConnectedClientsListInTable = true;
const showClientsPositionListInTable = true;
const showHistoryClientsListInTable = true;

/*** Constansts for admin UI ***/
const connectedClientsTableId = "#connectedUsersTable";
const connectedClientsDivId = "connectedClientsTableDiv";
const positionTableId = "#usersPositionTable";
const positionsDivId = "positionTableDiv";
const historyClientsTableId = "#historyOfUsersTable";
const historyClientsDivId = "historyTableDiv";

/*** Model of object saved in CONNECTED USERS list
 * @username - username of client
 * @userId - NAF ID of client
 * @roomJoinTime - time connected to shared room
 * @roomLeaveTime - time of disconnect from room
 ***/
function ConnectedClientModelForConnectedClientsList(userId, roomJoin) {
    this.userName;
    this.userId = userId;
    this.roomJoinTime = roomJoin;
    this.roomLeaveTime;
}

/*** Model of object saved in CLIENT POSITION list
 * @username - username of client
 * @userId - NAF ID of client
 * @entityId - NAF entity ID find by @templateNameSearchPosition
 * @entityIdRotation - NAF entity ID find by @templateNameSearchRotation
 * @positionX , @positionY , @positionZ - position of client entity
 * @rotationX , @rotationY , @rotationZ - rotation of client entity
 ***/
function ConnectedClientForClientPositionList(userId) {
    this.userName;
    this.userId = userId;
    this.entityId;
    this.entityIdRotation;
    this.positionX;
    this.positionY;
    this.positionZ;
    this.rotationX;
    this.rotationY;
    this.rotationZ;
}


function setUsersHistory(userHistoryResponse) {
    clientsHistory = userHistoryResponse;
}


function getClientsHistoryWithParsedDate() {
    let parsedDatesList = clientsHistory;
    parsedDatesList.forEach(c => {
        c.roomJoinTime = dateParser(c.roomJoinTime);
        c.roomLeaveTime = dateParser(c.roomLeaveTime);
    });
    return parsedDatesList;
}


function initializationAdminComponents() {
    /*** Component for getting live connected users list ***/
    AFRAME.registerComponent("admin-connected-clients", {
        init: function () {
            /*** Listener for connection of another client
             * gets NAF ID of connected user and added client ID to connected users list
             * get also time of connection of client
             ***/
            console.info(
                "Using component admin-connected-clients for getting list of connected clients with getters: getConnectedClients() and getConnectedClientsWithParsedDate()"
            );
            usageOfConnectedClientsListComponent = true;
            document.body.addEventListener("clientConnected", function (evt) {
                /*** BroadcastAdmin secret to user to enable kicking users***/
                NAF.connection.broadcastData(
                    adminIdBroadcastChannel,
                    NAF.clientId.slice(0, 10)
                );
                let allConnectedClients = NAF.connection.getConnectedClients();
                // console.info("Connected clients from NAF getConnectedClients ", allConnectedClients);
                let connectedClientId = evt.detail.clientId;

                let easyrtcid;
                if (allConnectedClients) {
                    for (easyrtcid in allConnectedClients) {
                        if (allConnectedClients.hasOwnProperty(easyrtcid)) {
                            let value = allConnectedClients[easyrtcid];

                            if (value.easyrtcid === connectedClientId) {
                                let clientModelForConnectedClientsList = new ConnectedClientModelForConnectedClientsList(
                                    value.easyrtcid,
                                    value.roomJoinTime
                                );
                                connectedClients.push({...clientModelForConnectedClientsList, userName:getUserNameByOwnerId(connectedClientId)});
                                console.log(connectedClients)
                                break;
                            }
                        }
                    }
                }
                if (showConnectedClientsListInTable) {
                    displayConnectedClients();
                }
                // console.info("Connected users from list: ", connectedClients);
            });
        }
    });

    /*** Component for getting live positions of connected clients ***/
    AFRAME.registerComponent("admin-position-of-clients", {
        init: function () {
            /*** Event listener for entity creation
             * find entity by @templateNameSearchPosition or @templateNameSearchRotation
             * push client with attributes @userID and @entityID adn @entityIdRotation to - @clientPosition list ***/
            console.info(
                "Using component admin-position-of-clients for getting list of clients positions in scene with getter: getClientPosition()"
            );
            usageOfClientPositionComponent = true;
            // document.body.addEventListener("entityCreated", function (evt) {
            //     let element = evt.detail.el;
            //     let clientForClientPositionList;
            //     if (
            //         element.getAttribute("networked").template ===
            //         templateNameSearchPosition ||
            //         element.getAttribute("networked").template === cBotTemplateName
            //     ) {
            //         clientForClientPositionList = new ConnectedClientForClientPositionList(
            //             element.getAttribute("networked").owner
            //             //element.getAttribute("networked").networkId
            //         );
            //         clientForClientPositionList.entityId = element.getAttribute(
            //             "networked"
            //         ).networkId;
            //     }
            //     if (
            //         element.getAttribute("networked").template ===
            //         templateNameSearchRotation
            //     ) {
            //         clientForClientPositionList = new ConnectedClientForClientPositionList(
            //             element.getAttribute("networked").owner
            //             //element.getAttribute("networked").networkId
            //         );
            //         clientForClientPositionList.entityIdRotation = element.getAttribute(
            //             "networked"
            //         ).networkId;
            //     }
            //     if (clientForClientPositionList !== undefined) {
            //         let existingClientIndex = clientsPosition.findIndex(
            //             client => client.userId === clientForClientPositionList.userId
            //         );
            //         if (existingClientIndex !== -1) {
            //             if (
            //                 clientsPosition[existingClientIndex].entityIdRotation ===
            //                 undefined
            //             ) {
            //                 clientsPosition[existingClientIndex].entityIdRotation =
            //                     clientForClientPositionList.entityIdRotation;
            //             }
            //             if (clientsPosition[existingClientIndex].entityId === undefined) {
            //                 clientsPosition[existingClientIndex].entityId =
            //                     clientForClientPositionList.entityId;
            //             }
            //             if (clientsPosition[existingClientIndex].userName === undefined) {
            //                 setUsernameToClient(element.getAttribute("networked").owner);
            //             }
            //         } else {
            //             clientsPosition.push(clientForClientPositionList);
            //             setUsernameToClient(element.getAttribute("networked").owner);
            //         }
            //         anyClientIsConnected = true;
            //     }
            // });
        },

        tick: function () {
            if (!adminIsConnected ||  getClientsObjectsDOM().length===0 || !showClientsPositionListInTable) return;
            displayClientsPositionsInTable();
        },

    });

    /*** Component for using client history functionality ***/
    AFRAME.registerComponent("admin-history-of-clients", {
        init: function () {
            console.info(
                "Using component admin-history-of-clients for getting list of connected clients with getters: getClientsHistory() and getClientsHistoryWithParsedDate()"
            );
            document.body.addEventListener("connected", function (evt) {
                enableUserHistory = true;
            });
            document.body.removeEventListener("connected", function (evt) {
            });
        }
    });

    /*** Initialization component, for tables when the are allowed to used ***/
    AFRAME.registerComponent("admin-initialization", {
        init: function () {
            console.info(
                "Using component admin-initialization which handles clientDisconnectEvent"
            );
            /*** Listener when admin is connected ***/
            document.body.addEventListener("connected", function (evt) {
                /*** IMPORTANT
                 * @adminIsConnected - used in messages, history of users can be used separately
                 ***/
                adminIsConnected = true;
                if (enableUserHistory) {
                    getUserHistory();
                }


                /*** Only tables initialization ***/
                if (showClientsPositionListInTable && usageOfClientPositionComponent) {
                    initTableForClientsPositions();
                }
                if (
                    showConnectedClientsListInTable &&
                    usageOfConnectedClientsListComponent
                ) {
                    initTableListOfConnectedClients();
                }
                if (showHistoryClientsListInTable && enableUserHistory) {
                    initTableForHistoryOfUsers();
                }
            });

            /*** Event listener for disconnection client
             * gets disconnected client ID and removes client from both lists
             ***/
            document.body.addEventListener(
                "clientDisconnected",
                function clientDisconnected(evt) {
                    let disconnectedClientId = evt.detail.clientId;
                    if (connectedClients.length > 0) {
                        let leaveUserListIndex = connectedClients.findIndex(
                            user => user.userId === disconnectedClientId
                        );
                        connectedClients[
                            leaveUserListIndex
                            ].roomLeaveTime = NAF.connection.getServerTime();
                        console.log(connectedClients[
                            leaveUserListIndex
                            ])
                        console.log('nad tym')
                        if (enableUserHistory) {
                            console.log('this')
                            sendClientDataToServer(connectedClients[leaveUserListIndex]);
                        }
                        connectedClients = connectedClients.filter(
                            x => x.userId !== disconnectedClientId
                        );
                        // console.info("Update list of connected users after client disconnected", connectedClients);
                        if (showConnectedClientsListInTable) {
                            displayConnectedClients();
                        }
                    }

                }
            );
        }
    });

    /*** Handler is admin refresh page ***/
    window.addEventListener("beforeunload", event => {
        connectedClients.length = 0;
        clientsHistory.length = 0;
    });
}


/*** Function sends data to server about disconnected user
 * @projectUrl a @saveUserEndpoint - needed
 ***/
function sendClientDataToServer(user) {
    console.log('TRYING TO POST', user)

    if (user.userName === undefined || user.userName === adminHistoryUsername || user.userName === cBotHistoryUsername) {
        return;
    }
    console.log('posting data', user)
    let xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.open("POST", projectUrl + saveUserActivityEndpoint);
    xhr.setRequestHeader("content-type", "application/json;charset=UTF-8");
    xhr.setRequestHeader("cache-control", "no-cache");
    xhr.setRequestHeader("isAuthenticated", adminIsConnected);
    let userParsed = JSON.stringify(user);
    xhr.send(userParsed);
    xhr.onload = function () {
        let responseObj = xhr.response;
        if (responseObj === "OK") {
            getUserHistory();
        } else {
            console.error(
                xhr.status +
                "Something went wrong while saving data about disconnected user on server!" +
                "Endpoint URL:" +
                projectUrl +
                saveUserActivityEndpoint
            );
        }
    };
}

/*** Function for getting data about users activity from server
 * @projectUrl a @getUserHistoryEndpoint - needed
 ***/
function getUserHistory() {
    let xhr = new XMLHttpRequest();
    xhr.withCredentials = true;
    xhr.open("GET", projectUrl + getUserHistoryEndpoint);
    xhr.setRequestHeader("content-type", "application/json;charset=UTF-8");
    xhr.setRequestHeader("cache-control", "no-cache");
    xhr.setRequestHeader("isAuthenticated", adminIsConnected);
    xhr.send();
    xhr.onload = function () {
        let responseObj = xhr.response;
        if (xhr.status === 200) {
            setUsersHistory(JSON.parse(responseObj));
            // console.info("Response history users object: ", JSON.parse(responseObj));
            if (showHistoryClientsListInTable) {
                displayUsersHistory();
            }
        } else {
            console.error(
                xhr.status +
                "Something went wrong while getting data about users from server!" +
                "Endpoint URL:" +
                projectUrl +
                getUserHistoryEndpoint
            );
        }
    };
}

/*** Initialization TABLES
 * @connectedUsersTable
 * @clientsPositionTable
 * @clientsHistoryTable
 ***/
function initTableListOfConnectedClients() {
    document.getElementById(connectedClientsDivId).style.display = "block";
    let connectedClientsTable = $(connectedClientsTableId);
    connectedClientsTable.on("post-body.bs.table", function (e) {
        $('[data-toggle="hoverPopup"]').popover();
    });
    if (connectedClientsTable) {
        console.info("Using table for showing connectedClients");
        connectedClientsTable.bootstrapTable({undefinedText: "---"});
    } else {
        console.error("Table with ID: " + connectedClientsTableId + " not found!");
    }
}

function initTableForClientsPositions() {
    document.getElementById(positionsDivId).style.display = "block";
    let clientsPositionTable = $(positionTableId);
    if (clientsPositionTable) {
        console.info("Using table for showing clientsPosition");
        clientsPositionTable.bootstrapTable({undefinedText: "---", data: getClientsObjectsDOM()});
    } else {
        console.error("Table with ID: " + positionTableId + " not found!");
    }
}

function initTableForHistoryOfUsers() {
    document.getElementById(historyClientsDivId).style.display = "block";
    let historyClientsTable = $(historyClientsTableId);
    historyClientsTable.on("post-body.bs.table", function (e) {
        $('[data-toggle="showInfo"]').popover();
    });
    if (historyClientsTable) {
        console.info("Using table for showing clientsHistory");
        historyClientsTable.bootstrapTable({undefinedText: "---"});
    } else {
        console.error("Table with ID: " + historyClientsTableId + " not found!");
    }
}

/*** Fill tables with data
 * @connectedUsersTable
 * @clientsPositionTable
 * @clientsHistoryTable
 ***/
function displayConnectedClients() {
    let connectedClientsTable = $(connectedClientsTableId);
    if (connectedClientsTable) {
        connectedClientsTable.bootstrapTable("load", connectedClients);
    } else {
        console.error("Table with ID: " + connectedClientsTableId + " not found!");
    }
}

function displayClientsPositionsInTable() {
    let clientsPositionTable = $(positionTableId);
    if (clientsPositionTable) {
        //REMOVED clientsPosition
        clientsPositionTable.bootstrapTable("load", getClientsObjectsDOM());
    } else {
        console.error("Table with ID: " + positionTableId + " not found!");
    }
}

function displayUsersHistory() {
    let historyClientsTable = $(historyClientsTableId);
    if (historyClientsTable) {
        historyClientsTable.bootstrapTable("load", clientsHistory);
    } else {
        console.error("Table with ID: " + historyClientsTableId + " not found!");
    }
}

function rowStyles(row, index) {
    if (row.userName === adminHistoryUsername) {
        return {
            css: {
                "background-color": "red",
                "font-weight": "bold"
            }
        };
    }

    if (row.userName === cBotHistoryUsername) {
        return {
            css: {
                "background-color": "yellow",
                "font-weight": "bold"
            }
        };
    }

    if (row.kickedUser === true) {
        return {
            css: {
                "background-color": "orange"
            }
        };
    }
    return {
        css: {}
    };
}

function tooltipConnectedClientsTable(row, index) {
    if (
        row.userName === adminHistoryUsername ||
        row.userName === cBotHistoryUsername
    ) {
        return {
            "data-toggle": "hoverPopup",
            "data-placement": "bottom",
            "data-trigger": "hover",
            "data-content": [
                "This is " + row.userName + " and can not be kicked from scene!"
            ].join(", ")
        };
    }
}

function tooltipHistoryClientsTable(row, index) {
    if (row.kickedUser === true) {
        return {
            "data-toggle": "showInfo",
            "data-placement": "bottom",
            "data-trigger": "hover",
            "data-content": [
                "This user " + row.userName + " was kicked from scene!"
            ].join(", ")
        };
    }
}

/*** Date formatter function using in Tables ***/
function dateParser(rawDate, a, b) {
    let date = new Date(rawDate);
    let months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
    ];
    let year = date.getFullYear();
    let month = months[date.getMonth()];
    let dayDate = date.getDate();
    // Hours part from the timestamp
    let hours = date.getHours();
    // Minutes part from the timestamp
    let minutes = "0" + date.getMinutes();
    // Seconds part from the timestamp
    let seconds = "0" + date.getSeconds();

    return (dayDate + " " + month + " " + year + " time " + hours + ":" + minutes.substr(-2) + ":" + seconds.substr(-2));
}

function kickSelectedClientsFromTable() {
    let selectedClients = $(connectedClientsTableId).bootstrapTable("getAllSelections");
    kickClientsFromScene(selectedClients);
}

function kickClientsFromScene(selectedClients) {
    selectedClients.forEach(function (user) {
        NAF.connection.sendData(user.userId, kickDataChannel, "kick");
    });
}

initializationAdminComponents();
