/*** Script for getting information from NAF about connected clients
 * @templateNameSearchPosition - template to select another clients positions
 * @clientConnected - flag, if admin is connected to scene
 * @anyClientConnected - flag about any record from NAF if client is connected
 * @classNameToGetUsername - classname for getting username from shared entity
 ***/
const templateNameSearchId = "#avatar-body";
let clientConnected;
let anyClientConnected = false;
const classNameToGetUsername = "idtext";

/*** Lists of connected clients and their position ***/
let clientsPosition = [];
const getClientsEntitiesDOM = () => document.getElementsByClassName('bodyavatar')
const getUserNameByOwnerId = (ownerId) => {
    const elementWithUsername = document.getElementsByClassName(classNameToGetUsername);
    if (elementWithUsername) {
        for (let item of elementWithUsername) {
            if (
                item.parentEl.components.networked.attrValue.owner === ownerId
            ) {
                return clientUsername = item.components.text.attrValue.value;
                break;
            }
        }
    }
}
const getClientsObjectsDOM = () => {
    const clientsPositions = [];
    getClientsEntitiesDOM().forEach((client) => {
        const clientNetworked = client.getAttribute('networked');
        //toto tu necham keby trebalo specialne pre cbota abo co
        // if (
        //     client.getAttribute("networked").networkId ===
        //     templateNameSearchRotation
        // ) {
        //
        // }
        const entityIdRotation = client.querySelector('.avatar').getAttribute('networked').networkId;
        let clientToArray = {
            userName: getUserNameByOwnerId(clientNetworked.owner),
            entityId: clientNetworked.networkId,
            userId: clientNetworked.owner,
            entityIdRotation
        };
        if (clientNetworked.networkId) {
            let clientEntityPosition = NAF.entities.getEntity(clientNetworked.networkId)
                .object3D.position;
            const positionX = clientEntityPosition.x.toFixed(4);
            const positionY = clientEntityPosition.y.toFixed(4);
            const positionZ = clientEntityPosition.z.toFixed(4);
            clientToArray = {...clientToArray, positionX, positionY, positionZ};
        }
        if (entityIdRotation) {
            let clientEntityRotation = NAF.entities.getEntity(
                entityIdRotation
            ).object3D.rotation;
            const rotationX = clientEntityRotation.x.toFixed(4);
            const rotationY = clientEntityRotation.y.toFixed(4);
            const rotationZ = clientEntityRotation.z.toFixed(4);
            clientToArray = {...clientToArray, rotationX, rotationY, rotationZ};
        }
        clientToArray && clientsPositions.push(clientToArray);
    })
    return clientsPositions;
}

/*** Model of object saved in CLIENT POSITION list
 * @username - username of client
 * @userId - NAF ID of client
 * @entityId - NAF entity ID find by @templateNameSearchPosition
 * @positionX , @positionY , @positionZ - position of client entity
 * @rotationX , @rotationY , @rotationZ - rotation of client entity
 ***/
function ConnectedClientForClientPositionList(userId, entityId) {
    this.userName = null;
    this.userId = userId;
    this.entityId = entityId;
    this.positionX = null;
    this.positionY = null;
    this.positionZ = null;
}

/*** Component for getting live positions of connected clients ***/
AFRAME.registerComponent("position-of-clients", {
    init: function () {
        /*** Listener when client is connected ***/
        document.body.addEventListener("connected", function (evt) {
            /*** IMPORTANT
             * @clientConnected - set client connected
             ***/
            clientConnected = true;
        });

        /*** Event listener for entity creation
         * find entity by @templateNameSearchPosition
         * push client with attributes @userID and @entityID to - @clientPosition list ***/
        document.body.addEventListener("entityCreated", function (evt) {
            let element = evt.detail.el;
            if (element.getAttribute("networked").template === templateNameSearchId) {
                let clientForClientPositionList = new ConnectedClientForClientPositionList(
                    element.getAttribute("networked").owner,
                    element.getAttribute("networked").networkId
                );
                clientsPosition.push(clientForClientPositionList);
                setUsernameToClient(element.getAttribute("networked").owner);
                anyClientConnected = true;
            }
        });

        document.body.addEventListener("clientDisconnected", function (evt) {
            let disconnectedClientId = evt.detail.clientId;
            if (clientsPosition.length > 0) {
                clientsPosition = clientsPosition.filter(
                    user => user.userId !== disconnectedClientId
                );
                if (clientsPosition.length === 0) {
                    anyClientConnected = false;
                }
                console.info("Update list of clients positions after client disconnected", clientsPosition);
            }
        });
    },

    tick: function () {
        if (clientConnected && anyClientConnected) {
            this.updateLivePosition();
        }
    },

    /*** In tick interval refresh all clients position in @clientPosition list***/
    updateLivePosition: function () {
        clientsPosition=getClientsObjectsDOM().map((client) => {
            const clientInList = clientsPosition.find(
                user => user.userId === client.userId
            );
            if (clientInList) {
                clientInList.positionX = client.positionX;
                clientInList.positionY = client.positionY;
                clientInList.positionZ = client.positionZ;
            }
        });
        // clientsPosition.forEach(function (client) {
        //     if (client.entityId) {
        //         let clientEntity = NAF.entities.getEntity(client.entityId);
        //         client.positionX = clientEntity.object3D.position.x;//.toFixed(4);
        //         client.positionY = clientEntity.object3D.position.y;//.toFixed(4);
        //         client.positionZ = clientEntity.object3D.position.z;//.toFixed(4);
        //     }
        // });
    }
});

/*** Function to set username for clients
 * @retrievedClientId {number} - NAF id of client
 ***/
function setUsernameToClient(retrievedClientId) {
    let elementsWithUsername = document.getElementsByClassName(classNameToGetUsername);
    let clientUsername;

    if (elementsWithUsername != null) {
        for (let item of elementsWithUsername) {
            if (item.parentEl.components.networked.attrValue.owner === retrievedClientId) {
                clientUsername = item.components.text.attrValue.value;
                break;
            }
        }
        if (clientUsername != null) {
            // waiting space for loading entities
            // let clientIndexUsersPositionList = clientsPosition.findIndex(client => client.userId === retrievedClientId);
            let clientIndexUsersPositionList = clientsPosition.indexOf(retrievedClientId);

            if (clientIndexUsersPositionList !== -1) {
                clientsPosition[clientIndexUsersPositionList].userName = clientUsername;
            }
        }
    }
}