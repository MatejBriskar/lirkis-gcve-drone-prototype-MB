"use strict";

const mojClamp = (num, min, max) => Math.min(Math.max(num, min), max)

/**
 * Automatic controller for simulated drone using {@linkcode PIDPositionController} as a regulator
 * @param maxMsrblDst - maximum range of sensing users
 * @param safeDstMov - minimum safety distance for drone landing and taking off
 * @param safeAltitude - altitude used to move between positions and evade users
 * @constructor
 */
let DroneController = function (maxMsrblDst, safeDstMov, safeAltitude) {
    this.maxMsrblDst = maxMsrblDst;
    this.safeDstMov = safeDstMov;
    this.safeAltitude = safeAltitude;

    this.target = {};
    this.droneOn = false;
    this.droneHovering = false;
    this.droneLanding = false;
    this.droneEvading = false;
    this.droneLanded = false;

    this.obstacleDst = maxMsrblDst;
    this.reachedPosition = false;

    this.areaClear = false;

    this.lastCommand = -1;
    this.lastTarget = {};
    this.stayPos = {x: 0, y: 0, z: 0};
}

/**
 * Commands used by {@linkcode DroneController}
 * @type {{REACH_HOVER: number, STAY_HOVER: number, REACH_LAND: number, LAND: number}}
 */
DroneController.COMMAND = {
    LAND: 0,
    REACH_HOVER: 1,
    REACH_LAND: 2,
    STAY_HOVER: 3
}
Object.freeze(DroneController.COMMAND);

DroneController.prototype.updateAndEvaluate = function (command, targetPos, currentPos, obstaclesPos) {
    if (!Number.isInteger(command) || command < 0 || command > 3 || targetPos == null || currentPos == null || obstaclesPos == null) return [{
        x: 0,
        y: 0,
        z: 0
    }, false, false, false, false, false];

    // reset values
    this.droneOn = false;
    this.droneHovering = false;
    this.droneLanding = false;
    this.droneEvading = false;

    this.readSensors(currentPos, obstaclesPos);

    // when command changes
    if (this.lastCommand !== command) {
        this.lastCommand = command;

        this.reachedPosition = false;
        this.droneLanded = false;

        // if command changes to land or stay hover, remember position, at which to stay
        if (command === DroneController.COMMAND.LAND || command === DroneController.COMMAND.STAY_HOVER) {
            this.stayPos.x = currentPos.x;
            this.stayPos.y = this.safeAltitude;
            this.stayPos.z = currentPos.z;
        }
    }

    // when target changes
    if (this.lastTarget.x !== targetPos.x || this.lastTarget.y !== targetPos.y || this.lastTarget.z !== targetPos.z) {
        this.lastTarget.x = targetPos.x;
        this.lastTarget.y = targetPos.y;
        this.lastTarget.z = targetPos.z;

        this.reachedPosition = false;
        this.droneLanded = false;
    }

    // initialize target
    if (this.target.x == null || this.target.y == null || this.target.z == null) {
        this.target.x = currentPos.x;
        this.target.y = currentPos.y;
        this.target.z = currentPos.z;
    }

    switch (command) {
        case DroneController.COMMAND.LAND:
            this.landAndTurnOff(currentPos);
            break;
        case DroneController.COMMAND.REACH_HOVER:
            this.goToPosAndHover(currentPos, targetPos);
            break;
        case DroneController.COMMAND.REACH_LAND:
            this.goToPosAndLand(currentPos, targetPos);
            break;
        case DroneController.COMMAND.STAY_HOVER:
            this.stayAndHover(currentPos);
            break;
        default:
            this.stayAndHover(currentPos);
            break;
    }

    return [this.target, this.droneOn, this.droneHovering, this.droneEvading, this.droneLanding, this.droneLanded];
}

DroneController.prototype.readSensors = function (currentPos, obstaclesPos) {
    let shortestDst = this.maxMsrblDst;

    for (let i = 0, dst; i < obstaclesPos.length; i++) {
        dst = this.distanceBetween(currentPos, obstaclesPos[i]);

        if (dst < shortestDst) shortestDst = dst;
    }

    this.obstacleDst = shortestDst;

    this.areaClear = this.obstacleDst >= this.safeDstMov;
}

DroneController.prototype.landAndTurnOff = function (currentPos) {
    let newPos = {x: this.stayPos.x, y: currentPos.y, z: this.stayPos.z};

    // drone still in air, proceed in landing while checking for safety
    if (!this.droneLanded && currentPos.y >= 0.2) {
        this.droneOn = true;
        this.droneLanding = true;

        if (this.areaClear) { // everything clear, proceed in landing
            newPos.y = currentPos.y - 2;

            if (newPos.y < 0) newPos.y = 0;
        } else { // someone is closer, than allowed, return to safe altitude
            this.droneEvading = true;

            newPos.y = currentPos.y + 2;

            // climb to safe altitude at max
            if (newPos.y > this.safeAltitude) newPos.y = this.safeAltitude;
        }
    } else { // drone has landed
        this.droneLanded = true;

        // -1 means motors will be turned off
        newPos.y = -1;
    }

    this.setPosTo(this.target, newPos);
}

DroneController.prototype.goToPosAndHover = function (currentPos, targetPos) {
    this.droneOn = true;

    let newPos = {x: targetPos.x, y: currentPos.y, z: targetPos.z};

    // distance between drone and target position in X and Z axis
    let dstMoving = this.distanceBetween(currentPos, newPos);

    if (!this.reachedPosition && dstMoving < 0.5) this.reachedPosition = true;

    // is near target position on X and Z axis, reach target altitude
    if (this.reachedPosition) {
        if (this.areaClear) { // if area is clear, reach target height
            newPos.y = targetPos.y;
        } else { // if area is not clear, climb to safe altitude
            this.droneEvading = true;
            // this.reachedPosition = false;

            newPos.y = currentPos.y + 2;

            // climb to safe altitude at max
            if (newPos.y > this.safeAltitude) newPos.y = this.safeAltitude;
        }

        // drone has reached desired position
        this.droneHovering = this.distanceBetween(currentPos, targetPos) < 0.5;
    } else { // has not reached target position yet
        // if drone is still on the ground and area is not clear, do not take off
        if (currentPos.y < 0.2 && !this.areaClear) {
            this.droneEvading = true;

            // -1 means motors will be turned off
            newPos.y = -1;
        } else if (Math.abs(currentPos.y - this.safeAltitude) > 0.5) { // first climb to safe altitude
            // use saved target
            newPos.x = this.target.x;
            newPos.y = this.safeAltitude;
            newPos.z = this.target.z;
        } else { // then fly to target at safe altitude
            newPos.y = this.safeAltitude;
            newPos.z = this.target.z;
        }
    }

    this.setPosTo(this.target, newPos);
}

DroneController.prototype.goToPosAndLand = function (currentPos, targetPos) {
    this.droneOn = true;

    let newPos = {x: targetPos.x, y: currentPos.y, z: targetPos.z};

    // distance between drone and target position in X and Z axis
    let dstMoving = this.distanceBetween(currentPos, newPos);

    if (!this.reachedPosition && dstMoving < 0.5) this.reachedPosition = true;

    // is near target position, start landing procedure
    if (this.reachedPosition) {
        // drone still in air, proceed in landing while checking for safety
        if (!this.droneLanded && currentPos.y >= 0.2) {
            if (this.areaClear) { // everything clear, proceed in landing
                this.droneLanding = true;

                newPos.y = currentPos.y - 2;

                if (newPos.y < 0) newPos.y = 0;
            } else { // someone is closer than allowed, return to safe altitude
                this.droneEvading = true;

                newPos.y = currentPos.y + 2;

                // climb to safe altitude at max
                if (newPos.y > this.safeAltitude) newPos.y = this.safeAltitude;
            }
        } else { // drone has landed
            this.droneLanded = true;

            // -1 means motors will be turned off
            newPos.y = -1;
        }
    } else { // has not reached target position yet
        // if drone is still on the ground and area is not clear, do not take off
        if (currentPos.y < 0.2 && !this.areaClear) {
            this.droneEvading = true;

            // -1 means motors will be turned off
            newPos.y = -1;
        } else if (Math.abs(currentPos.y - this.safeAltitude) > 0.5) { // first climb to safe altitude
            // use saved target
            newPos.x = this.target.x;
            newPos.y = this.safeAltitude;
            newPos.z = this.target.z;
        } else { // then fly to target at safe altitude
            newPos.y = this.safeAltitude;
        }
    }

    this.setPosTo(this.target, newPos);
}

DroneController.prototype.stayAndHover = function (currentPos) {
    this.droneOn = true;

    this.droneHovering = this.distanceBetween(currentPos, this.stayPos) < 0.5;

    this.setPosTo(this.target, this.stayPos);
}

DroneController.prototype.setPosTo = function (target, pos) {
    target.x = pos.x;
    target.y = pos.y;
    target.z = pos.z;
}

DroneController.prototype.distanceBetween = function (pos1, pos2) {
    const dx = pos1.x - pos2.x, dy = pos1.y - pos2.y, dz = pos1.z - pos2.z;

    return Math.sqrt(dx * dx + dy * dy + dz * dz);
}
