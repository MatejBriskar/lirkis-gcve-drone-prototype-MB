"use strict";

/* Layout of quadcopter and its motors
*
*    1cw   2ccw
*       \ /
*        O
*       / \
*    4ccw  3cw
*/

// constants
// atmospheric density of air in kg/m^3
const ro = 1.225;
// gravitational constant
const g = -9.80665;
const sqrt2 = Math.sqrt(2);
/**
 * Command structure used by drone component as an interface between different control methods
 * @param [height = 0] - desired height in meters
 * @param [pitch = 0] - desired pitch in radians
 * @param [roll = 0] - desired roll in radians
 * @param [yaw = 0] - desired yaw in radians
 * @constructor
 */
let Command = function (height, pitch, roll, yaw) {
    this.height = height || 0;
    this.pitch = pitch || 0;
    this.roll = roll || 0;
    this.yaw = yaw || 0;
}

AFRAME.registerComponent('drone', {
    schema: {
        template: {default: ''},
        attachTemplateToLocal: {default: true},
        controlMode: {default: 'p2pauto'},
        // mass of quadcopter in kg
        // model used is DJI Phantom 4 Pro
        // https://www.dji.com/sk/phantom-4-pro/info#specs
        mass: {default: 1.388},
        motorMaxRPM: {default: 10000, type: 'int'},
        motorOffset: {default: {x: 0.285, y: 0.25, z: 0.285}},
        maxTiltDeg: {default: 20},
        thrustConstant: {default: 0.000005},
        dragConstant: {default: 0.000002},
        // propellers used are DJI Phantom 4 Series Low-Noise Propellers
        // https://store.dji.com/sk/product/phantom-4-series-low-noise-propellers
        propellerDiameter: {default: 24},
        propellerPitch: {default: 13.97},
        // automatic control parameters using cbot and p2p controllers
        maxMsrblDst: {default: 15},
        safeDstMov: {default: 2},
        safeAltitude: {default: 4}
    },

    init: function () {
        // if (this.data.template === '') throw new Error('Drone component: No template specified!');
        if (this.data.controlMode !== 'keyboard' && this.data.controlMode !== 'gamepad' && this.data.controlMode !== 'auto' && this.data.controlMode !== 'p2pauto') throw new Error('Drone component: Invalid controlMode entered!');
        if (this.data.mass <= 0) throw new Error('Drone component: Invalid mass entered!');
        if (!Number.isInteger(this.data.motorMaxRPM) || this.data.motorMaxRPM <= 0) throw new Error('Drone component: Invalid motorMaxRPM entered!');
        if (!Number.isInteger(this.data.maxTiltDeg) || this.data.maxTiltDeg <= 0) throw new Error('Drone component: Invalid maxTiltDeg entered!');
        if (this.data.thrustConstant <= 0) throw new Error('Drone component: Invalid thrustConstant entered!');
        if (this.data.dragConstant <= 0) throw new Error('Drone component: Invalid dragConstant entered!');
        if (this.data.propellerDiameter <= 0) throw new Error('Drone component: Invalid propellerDiameter entered!');
        if (this.data.propellerPitch <= 0) throw new Error('Drone component: Invalid propellerPitch entered!');
        if (this.data.controlMode === 'gamepad') throw new Error('Drone component: Gamepad control not implemented yet!');

        // flag for body initialized
        this.isBodyInit = false;

        this.pidController = null;
        this.p2pPidController = null;

        // some constants used in thrust equation
        this.kToB = this.data.thrustConstant / this.data.dragConstant;
        this.ad = ro * Math.PI * Math.pow((0.0254 * cmToInches(this.data.propellerDiameter)), 2) / 4;
        this.dp = Math.pow((cmToInches(this.data.propellerDiameter) / (3.29546 * cmToInches(this.data.propellerPitch))), 1.5);

        // motor setup
        this.motor1RPM = 0;
        this.motor2RPM = 0;
        this.motor3RPM = 0;
        this.motor4RPM = 0;

        // check against invalid values
        let mOffset = this.data.motorOffset;
        mOffset.x = Math.abs(mOffset.x) || 0;
        mOffset.y = Math.abs(mOffset.y) || 0;
        mOffset.z = Math.abs(mOffset.z) || 0;

        // setup motor positions
        this.motors = [
            {x: -mOffset.x, y: mOffset.y, z: -mOffset.z},
            {x: mOffset.x, y: mOffset.y, z: -mOffset.z},
            {x: mOffset.x, y: mOffset.y, z: mOffset.z},
            {x: -mOffset.x, y: mOffset.y, z: mOffset.z}
        ];

        // l - distance between any rotor and center of the drone in meters
        // let v = new Ammo.btVector3(mOffset.x, 0, mOffset.z);
        // this.l = v.length();

        // internal property used for manual control
        this.targetHeight = 0;

        // movement commands
        this.movement = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            rotLeft: false,
            rotRight: false,
            ascend: false,
            descend: false
        }

        // index of current checkpoint
        this.checkpointIndex = 0;

        // retrieve all checkpoints in the scene
        this.checkpoints = [];
        document.querySelectorAll('[drone-checkpoint]').forEach(point => {
            this.checkpoints.push(point);
        });

        // initialize control methods
        this.initControl();


        // add cannon js physical body
        // this.el.setAttribute('dynamic-body', {mass: this.data.mass, shape: 'box'});

        // debug visualizing positions of motors
        /*for (let i = 0; i < motors.length; i++) {
            let el = document.createElement('a-sphere');
            el.setAttribute("radius", 0.05);
            let pos = motors[i];
            el.object3D.position.x = pos.x;
            el.object3D.position.y = pos.y;
            el.object3D.position.z = pos.z;
            drone.appendChild(el);
        }*/

        // debug vectors
        /*let scene = this.el.sceneEl.object3D;

        const dir = new THREE.Vector3(0, 0, 1);

        //normalize the direction vector (convert to vector of length 1)
        dir.normalize();

        const origin = new THREE.Vector3(0, 1, -1);

        this.arrowHelper = new THREE.ArrowHelper(dir, origin, 1, 0xff0000);
        scene.add(this.arrowHelper);

        this.arrowHelper2 = new THREE.ArrowHelper(dir, origin, 1, 0x00ff00);
        scene.add(this.arrowHelper2);

        this.arrowHelper3 = new THREE.ArrowHelper(dir, origin, 1, 0x0000ff);
        scene.add(this.arrowHelper3);*/

        this.onBodyInit = this.onBodyInit.bind(this);
        document.body.addEventListener('body-loaded', (e) => {
            console.log('body loaded');
            this.onBodyInit();
        });

        this.el.setAttribute('ammo-body', {type: 'dynamic', mass: this.data.mass});
        this.el.setAttribute('ammo-shape', {type: 'box', fit: 'manual', halfExtents: '0.3 0.1 0.3'});


    },

    update: function (oldData) {
        if (this.isBodyInit) { // update hover throttle in case parameters have changed
            let hoverThrust = this.getHoverThrust(Math.abs(g) * this.data.mass) / 4;
            console.log(this.el.body.hoverThrottle)
            this.el.body.hoverThrottle = this.getMotorRPMFromThrust(hoverThrust);
            console.log(this.el.body.hoverThrottle)
            this.pidController.updateHoverThrottle();

            if (this.data.controlMode === 'auto') this.pidController.setMode(PIDController.MODE.AUTO);
            else this.pidController.setMode(PIDController.MODE.MANUAL);
        }
    },

    initControl: function () {
        // values for cbot and p2p controllers
        this.cbotCommand = 1;
        this.p2pCommand = DroneController.COMMAND.REACH_HOVER;
        this.botOn = false;
        this.botCleaning = false;
        this.botEvading = false;
        this.botHovering = false;
        this.botLanding = false;
        this.botLanded = false;
        this.angleInMin = 0;
        this.dst = 0;
        this.defaultHeight = 2;

        this.lastTime = 0; // used for delta time calculations
        this.accumulatedTime = 0; // updated using delta time
        this.waitTime = 0; // total wait time required

        this.controller = new cbot.CBotController(
            this.data.maxMsrblDst,
            this.data.safeDstMov,
            this.data.safeDstMov,
            1
        );

        // maxMsrblDst, safeDstMov, safeAltitude
        this.p2pcontroller = new DroneController(
            this.data.maxMsrblDst,
            this.data.safeDstMov,
            this.data.safeAltitude
        );

        this.setupKeyboardControls();
    },

    // body initialized
    onBodyInit: function () {
        const physicsSystem = document.querySelector('a-scene').systems.physics;
        const world = physicsSystem.driver.physicsWorld;

        const fixedTimeStep = 1000 / 144;

        const maxSubSteps = 1;

        let hoverThrust = this.getHoverThrust(Math.abs(g) * this.data.mass) / 4;
        this.el.body.hoverThrottle = this.getMotorRPMFromThrust(hoverThrust);
        this.p2pPidController = new PIDPositionController(this.el.body, this.data.motorMaxRPM, this.data.maxTiltDeg);

        let mode = this.data.controlMode === 'auto' ? PIDController.MODE.AUTO : PIDController.MODE.MANUAL;
        this.pidController = new PIDController(this.el.body, this.data.motorMaxRPM, this.data.maxTiltDeg, mode);

        this.el.body.velocity = () => this.el.body.getLinearVelocity();
        this.isBodyInit = true;
        this.lastTime = new Date().getTime();

        this.signalObj = this.el.querySelector('.drone-signal');
        const preStep = this.preStep.bind(this);
        const clock = new THREE.Clock();

        function updatePhysics() {
            let deltaTime = clock.getDelta();

            world.stepSimulation(deltaTime, 10);
            preStep()
            requestAnimationFrame(updatePhysics);
        }

        updatePhysics();


    },

    onKeyDown: function (e) {
        this.updateKeys(e, true);
        //
        // if (e.keyCode === 69) {
        //     const pos = new Ammo.btVector3(-0.285, this.el.object3D.position.y, -0.285);
        //     // const pos2 = new Ammo.btVector3(-1000, this.el.object3D.position.y,1100);
        //     const force = new Ammo.btVector3(0, 0, 8)
        //     // const force2 = new Ammo.btVector3(0, 40, 0)
        //     this.el.body.activate();
        //     this.el.body.applyForce(force, pos);
        //     Ammo.destroy(pos)
        //     Ammo.destroy(force)
        // }

    },

    onKeyUp: function (e) {
        this.updateKeys(e, false);

    },

    updateKeys: function (e, v) {
        if (e.repeat === true) return;

        if (e.keyCode === this.keyMoveForward) this.movement.forward = v;
        else if (e.keyCode === this.keyMoveBackward) this.movement.backward = v;
        else if (e.keyCode === this.keyMoveLeft) this.movement.left = v;
        else if (e.keyCode === this.keyMoveRight) this.movement.right = v;
        else if (e.keyCode === this.keyRotateLeft) this.movement.rotLeft = v;
        else if (e.keyCode === this.keyRotateRight) this.movement.rotRight = v;
        else if (e.keyCode === this.keyAscend) this.movement.ascend = v;
        else if (e.keyCode === this.keyDescend) this.movement.descend = v;
    },

    setupKeyboardControls: function () {
        this.keyMoveForward = 73; // i
        this.keyMoveBackward = 75; // k
        this.keyMoveLeft = 74; // j
        this.keyMoveRight = 76; // l
        this.keyRotateLeft = 85; // u
        this.keyRotateRight = 79; // o
        this.keyAscend = 77; // m
        this.keyDescend = 78; // n

        this.onKeyDown = this.onKeyDown.bind(this);
        document.addEventListener('keydown', this.onKeyDown);

        this.onKeyUp = this.onKeyUp.bind(this);
        document.addEventListener('keyup', this.onKeyUp);
    },

    // calculate user distances from drone
    getUsersDistances: function (currentPos) {
        let distances = [];
        let i;

        for (i = 0; i < 8; i++) {
            distances[i] = this.data.maxMsrblDst;
        }

        // check for 2 positions, one for bottom of avatar, one for top
        let clientPos = new Ammo.btVector3()
        let clientPos2 = new Ammo.btVector3()
        let directionVector = new Ammo.btVector3()
        let angleInRad, angleInDeg, dst, cp, index, dstTop;


        for (i = 0; i < clientsPosition.length; i++) {
            cp = clientsPosition[i];
            clientPos.set(cp.positionX, cp.positionY, cp.positionZ);
            clientPos2.set(cp.positionX, cp.positionY + 2, cp.positionZ);

            // calculate distance
            dst = currentPos.distanceTo(clientPos);
            dstTop = currentPos.distanceTo(clientPos2);

            if (dst <= dstTop) { // bottom is closer
                directionVector.subVectors(clientPos, currentPos);
            } else { // top is closer
                directionVector.subVectors(clientPos2, currentPos);
                dst = dstTop;
            }

            // calculate angle between bot and client
            angleInRad = Math.atan2(directionVector.x, -directionVector.z);
            angleInDeg = wrapAngle(THREE.Math.radToDeg(angleInRad), 0, 360);

            index = Math.floor(angleInDeg / 45);

            // only set smallest distance
            if (dst < distances[index]) {
                distances[index] = dst;
            }
        }

        return distances;
    },
    // update movement
    preStep: function (body) {
        if (!this.isBodyInit)
            return;
        let values;

        if (this.data.controlMode === 'p2pauto') {
            let command = this.receiveCommand();
            //tu sa vola pidControler ak je mode auto
            this.p2pPidController.update({x: command.pitch, y: command.height, z: command.roll}, command.yaw);
            values = this.p2pPidController.getMotorValues();
        } else {
            let command = this.receiveCommand();
            this.pidController.update(command.height, command.pitch, command.roll, command.yaw);
            values = this.pidController.getMotorValues();
        }

        this.motor1RPM = values[0];
        this.motor2RPM = values[1];
        this.motor3RPM = values[2];
        this.motor4RPM = values[3];

        this.motor1RPM = mojClamp(this.motor1RPM, 0, this.data.motorMaxRPM);
        this.motor2RPM = mojClamp(this.motor2RPM, 0, this.data.motorMaxRPM);
        this.motor3RPM = mojClamp(this.motor3RPM, 0, this.data.motorMaxRPM);
        this.motor4RPM = mojClamp(this.motor4RPM, 0, this.data.motorMaxRPM);

        let m1thrust = this.getMotorThrust(this.motor1RPM);
        let m1drag = this.getMotorTorqueFromThrust(m1thrust) / sqrt2;
        let m2thrust = this.getMotorThrust(this.motor2RPM);
        let m2drag = this.getMotorTorqueFromThrust(m2thrust) / sqrt2;
        let m3thrust = this.getMotorThrust(this.motor3RPM);
        let m3drag = this.getMotorTorqueFromThrust(m3thrust) / sqrt2;
        let m4thrust = this.getMotorThrust(this.motor4RPM);
        let m4drag = this.getMotorTorqueFromThrust(m4thrust) / sqrt2;


        let m1Force = new Ammo.btVector3(m1drag, m1thrust, -m1drag);
        let m2Force = new Ammo.btVector3(-m2drag, m2thrust, -m2drag);
        let m3Force = new Ammo.btVector3(-m3drag, m3thrust, m3drag);
        let m4Force = new Ammo.btVector3(m4drag, m4thrust, m4drag);



// Calculate the force vector in local coordinates using the cross product
//         const localTorque = pos1.op_mul(localForce);

// // Convert the torque vector to world coordinates
//         let worldTorque = new Ammo.btVector3();

        // this.el.getWorldTransform().getBasis().op_mul(localTorque, worldTorque);

        // this.el.body.applyCentralForce(worldTorque);


        // let totalForce = new Ammo.btVector3(m1drag + (- m2drag) +(- m3drag) + m4drag, m1thrust + m2thrust + m3thrust + m4thrust, -m1drag - m2drag + m3drag + m4drag);

        // pos1.applyQuaternion(this.el.body.getOrientation());




        console.log('m1force')
        console.log(m1drag, m1thrust, -m1drag);
        console.log('m2force')
        console.log(-m2drag, m2thrust, -m2drag);
        console.log('m3force')
        console.log(-m3drag, m3thrust, m3drag);
        console.log('m4force')
        console.log(m4drag, m4thrust, m4drag);

        const mOffset = {x: 0.285, y: 0.25, z: 0.285};


        const pos1 = new Ammo.btVector3(-mOffset.x, mOffset.y, -mOffset.z);
        const pos2 = new Ammo.btVector3(mOffset.x, mOffset.y, -mOffset.z);
        const pos3 = new Ammo.btVector3(mOffset.x, mOffset.y, mOffset.z);
        const pos4 = new Ammo.btVector3(-mOffset.x, mOffset.y, mOffset.z);


        const vmult = function(v,q){
            const target =  new THREE.Vector3(0, 0, 0);

            let x = v.x(), y = v.y(), z = v.z();

            let qx = q.x, qy = q.y, qz = q.z, qw = q.w;

            // q*v
            let ix =  qw * x + qy * z - qz * y,
                iy =  qw * y + qz * x - qx * z,
                iz =  qw * z + qx * y - qy * x,
                iw = -qx * x - qy * y - qz * z;

            target.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            target.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            target.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

            return target;
        };

        const vectorToWorldFrame = (localVector, quaternion) => ( new THREE.Vector3(...vmult(localVector, quaternion)));
        const pointToWorldFrame = (localPoint,quaternion) => ( new THREE.Vector3(...vmult(localPoint,quaternion)));

        const force1Parsed = new Ammo.btVector3(...vectorToWorldFrame(m1Force, this.el.object3D.quaternion));
        const force2Parsed = new Ammo.btVector3(...vectorToWorldFrame(m2Force, this.el.object3D.quaternion));
        const force3Parsed = new Ammo.btVector3(...vectorToWorldFrame(m3Force, this.el.object3D.quaternion));
        const force4Parsed = new Ammo.btVector3(...vectorToWorldFrame(m4Force, this.el.object3D.quaternion));

        const pos1Parsed = new Ammo.btVector3(...pointToWorldFrame(pos1, this.el.object3D.quaternion, this.el.object3D.position));
        const pos2Parsed = new Ammo.btVector3(...pointToWorldFrame(pos2, this.el.object3D.quaternion, this.el.object3D.position));
        const pos3Parsed = new Ammo.btVector3(...pointToWorldFrame(pos3, this.el.object3D.quaternion, this.el.object3D.position));
        const pos4Parsed = new Ammo.btVector3(...pointToWorldFrame(pos4, this.el.object3D.quaternion, this.el.object3D.position));

        this.el.body.activate();
        this.el.body.applyForce(force1Parsed, pos1Parsed);
        this.el.body.applyForce(force2Parsed, pos2Parsed);
        this.el.body.applyForce(force3Parsed, pos3Parsed);
        this.el.body.applyForce(force4Parsed, pos4Parsed);

        Ammo.destroy(force1Parsed);
        Ammo.destroy(force2Parsed);
        Ammo.destroy(force3Parsed);
        Ammo.destroy(force4Parsed);
        Ammo.destroy(pos1Parsed);
        Ammo.destroy(pos2Parsed);
        Ammo.destroy(pos3Parsed);
        Ammo.destroy(pos4Parsed);
        Ammo.destroy(m1Force);
        Ammo.destroy(m2Force);
        Ammo.destroy(m3Force);
        Ammo.destroy(m4Force);
        Ammo.destroy(pos1);
        Ammo.destroy(pos2);
        Ammo.destroy(pos3);
        Ammo.destroy(pos4);


        // body.velocity.x *= 0.995;
        // body.velocity.y *= 0.995;
        // body.velocity.z *= 0.995;
        //
        // body.angularVelocity.x *= 0.995;
        // body.angularVelocity.y *= 0.995;
        // body.angularVelocity.z *= 0.995;
    },

    receiveCommand: function () {
        if (this.data.controlMode === 'keyboard') {
            return this.getKeyboardCommand();
        } else if (this.data.controlMode === 'gamepad') {
            return this.getGamepadCommand();
        } else if (this.data.controlMode === 'auto') {
            return this.getControllerCommand();
        } else if (this.data.controlMode === 'p2pauto') {
            return this.getP2pControllerCommand();
        }
    },

    // receive command from controller in auto mode
    getControllerCommand: function () {
        let command = new Command(this.defaultHeight);

        let currentPos = this.el.object3D.getWorldPosition(new THREE.Vector3());
        let distances = this.getUsersDistances(currentPos);
        let targetVector = new THREE.Vector3(), nextPos;

        if (this.checkpoints.length > this.checkpointIndex) {
            nextPos = this.checkpoints[this.checkpointIndex].object3D.getWorldPosition(new THREE.Vector3());
            targetVector = targetVector.subVectors(nextPos, currentPos);
        }

        // calculate angle to next position
        let angleInDeg = 0, angleInRad = 0, dst = 0;

        if (!isVector3Zero(targetVector)) {
            angleInRad = Math.atan2(targetVector.x, -targetVector.z);
            angleInDeg = wrapAngle((angleInRad) * (Math.PI / 180), 0, 360);
            dst = currentPos.distanceTo(nextPos);

            if (dst < 0.1) dst = 0;
        }

        // command, p2gAngleInMin, p2gDst, nne, ene, ese, sse, ssw, wsw, wnw, nnw
        let commands = this.controller.updateAndEvaluate(
            this.cbotCommand,
            Math.floor(angleInDeg * 60),
            dst,
            distances[0],
            distances[1],
            distances[2],
            distances[3],
            distances[4],
            distances[5],
            distances[6],
            distances[7]
        );

        this.botOn = commands[0];
        this.botCleaning = commands[1];
        this.botEvading = commands[2];
        this.angleInMin = commands[3];
        this.dst = commands[4];

        if (this.botOn) {
            // reach target height
            command.height = nextPos.y;
            if (this.dst < 0.1) {
                this.reachedCheckpoint();
            } else {
                // flip angles from controller representation to a-frame representation
                let targetAngleRad = (this.angleInMin / 60) * (Math.PI / 180);
                targetAngleRad = mapValueToRange(targetAngleRad, 0, 2 * Math.PI, 2 * Math.PI, 0);

                command.yaw = wrapAngle(targetAngleRad, -Math.PI, Math.PI);

                // if drone is rotated towards target
                if (Math.abs(command.yaw - this.el.object3D.rotation.y) < 0.1) {
                    command.pitch = (-20) * (Math.PI / 180);
                    ;

                    let tVec = new Ammo.btVector3()(targetVector.x, 0, targetVector.z).normalize();
                    let mVec = new Ammo.btVector3()(this.el.body.velocity.x, 0, this.el.body.velocity.z).normalize();
                    let cross = new THREE.Vector3().crossVectors(tVec, mVec);

                    console.error(cross)
                    let a = tVec.angleTo(mVec);

                    // if heading towards checkpoint, check for corrections
                    if (a < Math.PI / 8 && this.el.body.velocity.length() > 2) {
                        command.roll = THREE.Math.degToRad(-20 * cross.y);
                    }
                }
            }
        }

        return command;
    },

    // receive command from p2p controller in p2pauto mode
    getP2pControllerCommand: function () {
        let command = new Command();

        let currentPos = this.el.object3D.getWorldPosition(new THREE.Vector3()), nextPos;

        if (this.checkpoints.length > this.checkpointIndex) {
            let checkpoint = this.checkpoints[this.checkpointIndex].object3D;

            nextPos = checkpoint.getWorldPosition(new THREE.Vector3());

            if (checkpoint.checkpointType === DRONE_CHECKPOINT_TYPE.LAND) {
                this.p2pCommand = DroneController.COMMAND.REACH_LAND;
            } else {
                this.p2pCommand = DroneController.COMMAND.REACH_HOVER;
            }

            this.waitTime = checkpoint.checkpointWaitTime || 0;
        } else {
            if (this.checkpoints.length > 0) {
                nextPos = this.checkpoints[this.checkpoints.length - 1].object3D.getWorldPosition(new THREE.Vector3());
            } else {
                nextPos = currentPos.clone();
                nextPos.y = 0;
            }
        }

        let obstacles = [];
        let cp, dst, dstTop;
        let clientPos = new THREE.Vector3();
        let clientPos2 = new THREE.Vector3();

        // check for 2 positions, one for bottom of avatar, one for top

        // const clientsPosition=document.querySelectorAll('.avatar');
        // console.log(clientsPosition)

        for (let i = 0; i < clientsPosition.length; i++) {
            cp = clientsPosition[i];
            clientPos.set(cp.positionX, cp.positionY, cp.positionZ);
            clientPos2.set(cp.positionX, cp.positionY + 2, cp.positionZ);

            // calculate distance
            dst = currentPos.distanceTo(clientPos);
            dstTop = currentPos.distanceTo(clientPos2);

            if (dst <= dstTop) { // bottom is closer
                obstacles.push(clientPos);
            } else { // top is closer
                obstacles.push(clientPos2);
            }
        }

        let commands = this.p2pcontroller.updateAndEvaluate(this.p2pCommand, nextPos, currentPos, obstacles);

        let targetPos = new THREE.Vector3(commands[0].x, commands[0].y, commands[0].z);
        this.botOn = commands[1];
        this.botHovering = commands[2];
        this.botEvading = commands[3];
        this.botLanding = commands[4];
        this.botLanded = commands[5];

        if (this.botOn) {
            // reach target height
            command.height = targetPos.y;

            this.dst = currentPos.distanceTo(nextPos);

            if (this.p2pCommand === DroneController.COMMAND.REACH_HOVER) {
                if (this.botHovering) {
                    // if drone should wait at point, dont check for distance, just if it is hovering
                    if (this.waitTime > 0) {
                        this.reachedCheckpoint();
                    } else if (this.dst < 0.1) { // otherwise reached point only when close enough
                        this.reachedCheckpoint();
                    }
                }
                command.pitch = targetPos.x;
                command.roll = targetPos.z;
            } else if (this.p2pCommand === DroneController.COMMAND.REACH_LAND) {
                if (this.botLanded) {
                    this.reachedCheckpoint();

                    // if drone should wait when landed, turn off motors
                    if (this.waitTime > 0) {
                        command.height = -1;
                    }
                } else {
                    command.pitch = targetPos.x;
                    command.roll = targetPos.z;
                }
            } else {
                command.pitch = targetPos.x;
                command.roll = targetPos.z;
            }
        } else {
            // tell pid controller to turn off motors
            command.height = -1;
        }

        this.updateColor();
        this.lastTime = new Date().getTime();

        return command;
    },

    reachedCheckpoint: function () {
        if (this.checkpointIndex >= this.checkpoints.length) return;

        if (this.waitTime > this.accumulatedTime) {
            this.accumulatedTime += this.getDeltaTime();
            return;
        } else { // reset accumulated time
            this.accumulatedTime = 0;
        }

        this.checkpointIndex++;

        console.log("Drone has reached checkpoint #" + this.checkpointIndex);

        if (this.checkpoints.length <= this.checkpointIndex) {
            this.checkpointIndex = 0;
            console.log("Drone reached all checkpoints. Repeating...");
        }
    },

    updateColor: function () {
        let color;

        if (this.botLanded) {
            color = this.botEvading ? "red" : "orange";
        } else if (this.botOn) {
            color = this.botEvading ? "red" : "green";
        } else {
            color = "white";
        }

        this.signalObj?.setAttribute("material", "color", color);
    },

    // receive command from keyboard in manual mode
    getKeyboardCommand: function () {

        const degToRad = (deg) => {
            return deg * Math.PI / 180;
        }

        let command = new Command(this.targetHeight);
        let buttonPressed = false;

        if (this.movement.forward === true) {
            command.pitch = degToRad(-20);
            buttonPressed = true;
        }
        if (this.movement.backward === true) {
            command.pitch = degToRad(20);
            buttonPressed = true;
        }
        if (this.movement.left === true) {
            command.roll = degToRad(20);
            buttonPressed = true;
        }
        if (this.movement.right === true) {
            command.roll = degToRad(-20);
            buttonPressed = true;
        }
        if (this.movement.ascend === true) {
            this.targetHeight += 0.025;
            command.height = this.targetHeight;
            buttonPressed = true;
        }
        if (this.movement.descend === true) {
            this.targetHeight -= 0.025;

            if (this.targetHeight < 0) {
                this.targetHeight = 0;
            }

            command.height = this.targetHeight;

            buttonPressed = true;
        }
        if (this.movement.rotLeft === true) {
            command.yaw = degToRad(-180);
            buttonPressed = true;
        }
        if (this.movement.rotRight === true) {
            command.yaw = degToRad(180);
            buttonPressed = true;
        }

        if (buttonPressed) {
            this.pidController.resetIntegrals();
        }

        return command;
    },

    // receive command from gamepad in manual mode
    getGamepadCommand: function () {
        throw new Error('getGamepadCommand: feature not implemented yet!');
    },

    // calculate dynamic thrust created by motor
    // if V0 = 0 then it calculates static thrust
    // https://www.electricrcaircraftguy.com/2014/04/propeller-static-dynamic-thrust-equation-background.html
    // returns value in N
    getMotorThrust: function (rpm, inflowVelocity) {
        inflowVelocity = inflowVelocity || 0; // inflow velocity in m/s

        let p = cmToInches(this.data.propellerPitch);
        return this.ad * (Math.pow((rpm * 0.0254 * p / 60), 2) - (rpm * 0.0254 * p / 60) * inflowVelocity) * this.dp;
    },

    // calculate motor torque from thrust using thrust to drag ratio
    getMotorTorqueFromThrust: function (thrust) {
        return thrust / this.kToB;
    },

    // calculate motor rpm from static thrust
    getMotorRPMFromThrust: function (thrust) {
        if (thrust < 0) return 0;

        return Math.sqrt(thrust / (this.ad * this.dp * Math.pow(0.0254 * cmToInches(this.data.propellerPitch) / 60, 2)));
    },

    // get total thrust needed to keep hovering
    getHoverThrust: function (gravForce) {
        let euler = new Ammo.btVector3();
        console.log(euler.x())
        Ammo.btQuaternion(euler);
        console.error(euler.x())
        const value = gravForce / (Math.cos(euler.x()) * Math.cos(euler.z()));
        Ammo.destroy(euler)
        return value;
    },

    getDeltaTime: function () {
        return new Date().getTime() - this.lastTime;
    },

    remove: function () {
        this.el.removeEventListener("body-init", this.onBodyInit);
        document.removeEventListener('keydown', this.onKeyDown);
        document.removeEventListener('keyup', this.onKeyUp);
    }
});

const DRONE_CHECKPOINT_TYPE = {
    REACH: "reach",
    LAND: "land"
}
Object.freeze(DRONE_CHECKPOINT_TYPE);

AFRAME.registerComponent("drone-checkpoint", {
    schema: {
        type: {default: DRONE_CHECKPOINT_TYPE.REACH, type: "string"},
        waitTime: {default: 0, type: 'int'}
    },

    init: function () {
        this.el.setAttribute("geometry", "primitive", "sphere");
        this.el.setAttribute("geometry", "radius", 0.1);

        let color = "white";

        switch (this.data.type) {
            case DRONE_CHECKPOINT_TYPE.REACH:
                this.el.object3D.checkpointType = DRONE_CHECKPOINT_TYPE.REACH;
                color = "green";
                break;
            case DRONE_CHECKPOINT_TYPE.LAND:
                this.el.object3D.checkpointType = DRONE_CHECKPOINT_TYPE.LAND;
                color = "red";
                break;
        }

        this.el.object3D.checkpointWaitTime = this.data.waitTime;

        this.el.setAttribute("material", "color", color);
    }
});

// global helper functions

// get angular velocity of rotor
function RPMtoRADs(rpm) {
    return rpm * 2 * Math.PI / 60;
}

function inToCm(inches) {
    return inches * 2.54;
}

function cmToInches(cm) {
    return cm * 0.393700787;
}

function wrapAngle(angle, min, max) {
    let range = max - min;

    if (range <= 0) {
        return 0;
    }

    let result = (angle - min) % range;

    if (result < 0) {
        result += range;
    }

    return result + min;
}

function isVector3Zero(vector) {
    return vector.x === 0 && vector.y === 0 && vector.z === 0;
}

function mapValueToRange(value, fromMin, fromMax, toMin, toMax) {
    value = mojClamp(value, fromMin, fromMax);
    return (value - fromMin) * (toMax - toMin) / (fromMax - fromMin) + toMin;
}
