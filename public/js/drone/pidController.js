"use strict";

/**
 * PID controller used for stabilization and motor speed control
 * @param body - reference to {@linkcode CANNON.Body}
 * @param maxRpm - max RPMs of motors
 * @param maxTilt - max tilt angle in degrees
 * @param mode - functional mode of this controller, one of {@linkcode PIDController.MODE}
 * @param sampleTime - time between updates in ms
 * @constructor
 */
let PIDController = function (body, maxRpm, maxTilt, mode, sampleTime) {
    // input validation
    if (!Number.isInteger(maxRpm) || maxRpm <= 0) throw new Error('PIDController: Invalid maxRpm entered!');
    if (maxTilt <= 0) throw new Error('PIDController: Invalid maxTilt entered!');

    this.mode = mode || PIDController.MODE.MANUAL; // default mode is manual i.e. human controlled

    if (this.mode === PIDController.MODE.MANUAL || this.mode === PIDController.MODE.AUTO) this.mode = mode;
    else throw new Error('PIDController: Invalid mode entered!');

    this.drone = body;

    // throttle required for hovering
    this.hoverThrottle = body.hoverThrottle;

    // constants
    this.motorLimits = [0, maxRpm];
    this.throttleChangeLimit = this.motorLimits[1] - 1000;
    this.tiltLimits = [(-maxTilt / 180) * Math.PI, (maxTilt / 180) * Math.PI];
    this.yawControlLimits = [-900, 900];

    // configuration parameters
    this.linearP = [8000, 8000, 8000]; // 10000
    this.linearI = [0.05, 0.05, 0.05]; // 0.05
    this.linearD = [8000, 8000, 8000]; // 8000
    this.angularP = [2000, 2000, 2000]; // 2000
    this.angularI = [0.05, 0.05, 0.05]; // 0.05
    this.angularD = [30000, 30000, 30000]; // 30000

    if (sampleTime == null) { // if sample time not set, controller will update every time it is called
        this.sampleTime = sampleTime || 1000 / 144; // default sample time is 6,94 seconds = 144fps, if set to 0
        this.lastTime = this.getTime() - this.sampleTime;
    }

    // integral values
    this.xiTerm = 0;
    this.yiTerm = 0;
    this.ziTerm = 0;
    this.thetaiTerm = 0;
    this.phiiTerm = 0;
    this.gammaiTerm = 0;

    this.lastTheta = 0;
    this.lastPhi = 0;
    this.lastGamma = 0;

    // controller output for each motor
    this.m1 = 0;
    this.m2 = 0;
    this.m3 = 0;
    this.m4 = 0;
}

/**
 * PID controller mode
 * @type {{AUTO: number, MANUAL: number}}
 */
PIDController.MODE = {
    MANUAL: 0,
    AUTO: 1
}
Object.freeze(PIDController.MODE);

PIDController.prototype.getTime = function () {
    return new Date().getTime();
}

PIDController.prototype.wrapAngle = function (angle, min, max) {
    let range = max - min;

    if (range <= 0) {
        return 0;
    }

    let result = (angle - min) % range;

    if (result < 0) {
        result += range;
    }

    return result + min;
}

PIDController.prototype.getMotorValues = function () {
    return [this.m1, this.m2, this.m3, this.m4];
}

PIDController.prototype.resetIntegrals = function () {
    this.thetaiTerm = 0;
    this.phiiTerm = 0;
    this.gammaiTerm = 0;
}

PIDController.prototype.getMode = function () {
    return this.mode;
}

PIDController.prototype.setMode = function (m) {
    if (m !== PIDController.MODE.MANUAL && m !== PIDController.MODE.AUTO) {
        console.warn('Invalid mode entered');
        return;
    }

    this.mode = m;
}

PIDController.prototype.updateHoverThrottle = function () {
    let throttle = this.drone.hoverThrottle;

    if (throttle == null || throttle === 0) return;

    this.hoverThrottle = mojClamp(throttle, this.motorLimits[0], this.motorLimits[1]);
}

PIDController.prototype.update = function (desiredHeight, pitchCommand, rollCommand, yawCommand) {
    if (this.sampleTime != null) {
        let now = this.getTime();
        if (now - this.lastTime < this.sampleTime) return;

        this.lastTime = now;
    }

    // received command to shut motors off
    if (desiredHeight === -1) {
        this.m1 = 0;
        this.m2 = 0;
        this.m3 = 0;
        this.m4 = 0;
        return;
    }

    pitchCommand = pitchCommand || 0;
    rollCommand = rollCommand || 0;
    yawCommand = yawCommand || 0;
    let x = this.drone.el.components['position'].data.x;
    let y = this.drone.el.components['position'].data.y;
    let z = this.drone.el.components['position'].data.z;
    let xDot = this.drone.el.components['ammo-body'].body.velocity().x()
    let yDot = this.drone.el.components['ammo-body'].body.velocity().y()
    let zDot = this.drone.el.components['ammo-body'].body.velocity().z()
    function qte(quat) {

        const q0 = quat[0];
        const q1 = quat[1];
        const q2 = quat[2];
        const q3 = quat[3];

        const x = Math.atan2(2 * (q0 * q1 + q2 * q3), 1 - (2 * (q1 * q1 + q2 * q2)));
        const y = Math.asin(2 * (q0 * q2 - q3 * q1));
        const z = Math.atan2(2 * (q0 * q3 + q1 * q2), 1 - (2 * (q2 * q2 + q3 * q3)));

        const euler = {x, y, z};

        return (euler);
    };


    const quat = [this.drone.el.object3D.quaternion.w, this.drone.el.object3D.quaternion.x, this.drone.el.object3D.quaternion.y,
        this.drone.el.object3D.quaternion.z];

    const euler = qte(quat);

    let theta = euler.z; // pitch
    let phi = euler.x; // roll
    let gamma = euler.y; // yaw

    let thetaDot = theta - this.lastTheta;
    let phiDot = phi - this.lastPhi;
    let gammaDot = gamma - this.lastGamma;

    let y_error = desiredHeight - y;

    this.yiTerm += this.linearI[1] * y_error;

    let dest_y_dot = this.linearP[1] * y_error + this.linearD[1] * -yDot + this.yiTerm;
    let throttle = this.hoverThrottle + Math.min(Math.max(dest_y_dot, -this.throttleChangeLimit), this.throttleChangeLimit);

    let dest_theta = rollCommand;
    let dest_phi = pitchCommand;

    dest_theta = Math.min(Math.max(dest_theta, this.tiltLimits[0]), this.tiltLimits[1]);
    dest_phi = Math.min(Math.max(dest_phi, this.tiltLimits[0]), this.tiltLimits[1]);

    let theta_error = this.wrapAngle(theta - dest_theta, -Math.PI, Math.PI);
    let phi_error = this.wrapAngle(phi - dest_phi, -Math.PI, Math.PI);
    let gamma_dot_error;

    if (this.mode === PIDController.MODE.AUTO) {
        gamma_dot_error = this.wrapAngle(gamma - yawCommand, -Math.PI, Math.PI);
    } else {
        gamma_dot_error = yawCommand;
    }

    this.thetaiTerm += this.angularI[2] * theta_error;
    this.phiiTerm += this.angularI[0] * phi_error;
    this.gammaiTerm += this.angularI[1] * gamma_dot_error;
    let z_val = this.angularP[0] * phi_error + this.angularD[0] * phiDot + this.phiiTerm; // pitch
    let y_val = this.angularP[1] * gamma_dot_error + this.angularD[1] * gammaDot + this.gammaiTerm; // yaw

    let x_val = this.angularP[2] * theta_error + this.angularD[2] * thetaDot + this.thetaiTerm; // roll

    y_val = Math.min(Math.max(y_val, this.yawControlLimits[0]), this.yawControlLimits[1]);

    console.table(throttle, x_val, z_val, y_val)
    this.m1 = throttle + x_val - z_val + y_val;
    this.m2 = throttle - x_val - z_val - y_val;
    this.m3 = throttle - x_val + z_val + y_val;
    this.m4 = throttle + x_val + z_val - y_val;

    this.m1 = Math.min(Math.max(this.m1, this.motorLimits[0]), this.motorLimits[1]);
    this.m2 = Math.min(Math.max(this.m2, this.motorLimits[0]), this.motorLimits[1]);
    this.m3 = Math.min(Math.max(this.m3, this.motorLimits[0]), this.motorLimits[1]);
    this.m4 = Math.min(Math.max(this.m4, this.motorLimits[0]), this.motorLimits[1]);

    this.lastTheta = theta;
    this.lastPhi = phi;
    this.lastGamma = gamma;
}

/**
 * Improved PID controller, which uses target position instead of angles and height
 * @param body - reference to {@linkcode CANNON.Body}
 * @param maxRpm - max RPMs of motors
 * @param maxTilt - max tilt angle in degrees
 * @param sampleTime - time between updates in ms
 * @constructor
 */
let PIDPositionController = function (body, maxRpm, maxTilt, sampleTime) {
    PIDController.call(this, body, maxRpm, maxTilt, PIDController.MODE.AUTO, sampleTime);

    // configuration parameters
    this.linearP = [8000, 8000, 8000]; // 10000
    this.linearI = [0.05, 0.05, 0.05]; // 0.05
    this.linearD = [12000, 12000, 12000]; // 8000
    this.angularP = [5000, 5000, 5000];
    this.angularI = [0.05, 0.05, 0.05];
    this.angularD = [30000, 30000, 30000];
}

PIDPositionController.prototype = Object.create(PIDController.prototype);
PIDPositionController.prototype.constructor = PIDPositionController;

PIDPositionController.prototype.update = function (target, yawCommand) {

    //toto vola dron component
    if (false) {
        let now = this.getTime();

        if (now - this.lastTime < 1000/144) return;

        this.lastTime = now;
    }

    // received command to shut motors off
    if (target.y === -1) {
        this.m1 = 0;
        this.m2 = 0;
        this.m3 = 0;
        this.m4 = 0;
        return;
    }

    yawCommand = yawCommand || 0;

    let destX = target.x;
    let destY = target.y;
    let destZ = target.z;
    let x = this.drone.el.object3D.position.x;
    let y = this.drone.el.object3D.position.y;
    let z = this.drone.el.object3D.position.z;
    let xDot = this.drone.el.components['ammo-body'].body.velocity().x()
    let yDot = this.drone.el.components['ammo-body'].body.velocity().y()
    let zDot = this.drone.el.components['ammo-body'].body.velocity().z()

    function qte(quat) {

        const q0 = quat[0];
        const q1 = quat[1];
        const q2 = quat[2];
        const q3 = quat[3];

        const x = Math.atan2(2 * (q0 * q1 + q2 * q3), 1 - (2 * (q1 * q1 + q2 * q2)));
        const y = Math.asin(2 * (q0 * q2 - q3 * q1));
        const z = Math.atan2(2 * (q0 * q3 + q1 * q2), 1 - (2 * (q2 * q2 + q3 * q3)));

        const euler = {x, y, z};

        return (euler);
    };


    const quat = [this.drone.el.object3D.quaternion.w, this.drone.el.object3D.quaternion.x, this.drone.el.object3D.quaternion.y,
        this.drone.el.object3D.quaternion.z];

    const euler = qte(quat);

    let theta = euler.z; // pitch
    let phi = euler.x; // roll
    let gamma = euler.y; // yaw

    let thetaDot = theta - this.lastTheta;
    let phiDot = phi - this.lastPhi;
    let gammaDot = gamma - this.lastGamma;

    let x_error = destX - x;
    let y_error = destY - y;
    let z_error = destZ - z;

    this.xiTerm += this.linearI[0] * x_error;
    this.yiTerm += this.linearI[1] * y_error;
    this.ziTerm += this.linearI[2] * z_error;

    let dest_x_dot = this.linearP[0] * x_error + this.linearD[0] * -xDot + this.xiTerm;
    let dest_y_dot = this.linearP[1] * y_error + this.linearD[1] * -yDot + this.yiTerm;
    let dest_z_dot = this.linearP[2] * z_error + this.linearD[2] * -zDot + this.ziTerm;

    let throttle = this.hoverThrottle + Math.min(Math.max(dest_y_dot, -this.throttleChangeLimit), this.throttleChangeLimit);

    let dest_theta = dest_z_dot * Math.sin(gamma) - dest_x_dot * Math.cos(gamma);
    let dest_phi = dest_z_dot * Math.cos(gamma) + dest_x_dot * Math.sin(gamma);

    dest_theta = Math.min(Math.max(dest_theta, this.tiltLimits[0]), this.tiltLimits[1]);
    dest_phi = Math.min(Math.max(dest_phi, this.tiltLimits[0]), this.tiltLimits[1]);


    // allow for some error tolerance
    if (Math.abs(x_error) < 0.1 && Math.abs(z_error) < 0.1) {
        dest_theta = 0;
        this.thetaiTerm = 0;
        dest_phi = 0;
        this.phiiTerm = 0;
    }

    let theta_error = this.wrapAngle(theta - dest_theta, -Math.PI, Math.PI);
    let phi_error = this.wrapAngle(phi - dest_phi, -Math.PI, Math.PI);
    let gamma_dot_error = this.wrapAngle(gamma - yawCommand, -Math.PI, Math.PI);

    this.thetaiTerm += this.angularI[2] * theta_error;
    this.phiiTerm += this.angularI[0] * phi_error;
    this.gammaiTerm += this.angularI[1] * gamma_dot_error;

    let z_val = this.angularP[0] * phi_error + this.angularD[0] * phiDot + this.phiiTerm; // pitch
    let y_val = this.angularP[1] * gamma_dot_error + this.angularD[1] * gammaDot + this.gammaiTerm; // yaw
    let x_val = this.angularP[2] * theta_error + this.angularD[2] * thetaDot + this.thetaiTerm; // roll

    y_val = Math.min(Math.max(y_val, this.yawControlLimits[0]), this.yawControlLimits[1]);

    this.m1 = throttle + x_val - z_val + y_val;
    this.m2 = throttle - x_val - z_val - y_val;
    this.m3 = throttle - x_val + z_val + y_val;
    this.m4 = throttle + x_val + z_val - y_val;
    //
    this.m1 =  Math.min(Math.max(this.m1, this.motorLimits[0]), this.motorLimits[1]);
    this.m2 =  Math.min(Math.max(this.m2, this.motorLimits[0]), this.motorLimits[1]);
    this.m3 =  Math.min(Math.max(this.m3, this.motorLimits[0]), this.motorLimits[1]);
    this.m4 =  Math.min(Math.max(this.m4, this.motorLimits[0]), this.motorLimits[1]);


    this.lastTheta = theta;
    this.lastPhi = phi;
    this.lastGamma = gamma;
}
